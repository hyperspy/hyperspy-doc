

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>hyperspy.learn.mva module &mdash; HyperSpy 1.6.4 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/hyperspy.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/toggleprompt.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="hyperspy.learn.ornmf module" href="hyperspy.learn.ornmf.html" />
    <link rel="prev" title="hyperspy.learn.mlpca module" href="hyperspy.learn.mlpca.html" />
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25260850-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> HyperSpy
          

          
            
            <img src="../_static/hyperspy_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.6.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/install.html">Installing HyperSpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/signal.html">The Signal class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/interactive_operations_ROIs.html">Interactive Operations and Region of Interest (ROI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/signal1d.html">Signal1D Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/signal2d.html">Signal2D Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/visualisation.html">Data visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/mva.html">Machine learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/model.html">Model fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/eels.html">Electron Energy Loss Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/eds.html">Energy-Dispersive X-ray Spectrometry (EDS)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/dielectric_function.html">Dielectric function tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/electron_holography.html">Electron Holography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/io.html">Loading and saving data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/events.html">Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/big_data.html">Working with big data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/metadata_structure.html">Metadata structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/bibliography.html">Bibliography</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/git.html">Using Git and GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/testing.html">Running and writing tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/writing_docs.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/coding_style.html">Coding style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/lazy_computations.html">Tips for writing methods that work on lazy signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/speeding_up_code.html">Speeding up code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/writing_extensions.html">Writing packages that extend HyperSpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/useful_information.html">Useful information</a></li>
</ul>
<p class="caption"><span class="caption-text">API References</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">hyperspy</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="hyperspy.html">hyperspy package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="hyperspy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="hyperspy._components.html">hyperspy._components package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy._signals.html">hyperspy._signals package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.datasets.html">hyperspy.datasets package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.docstrings.html">hyperspy.docstrings package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.drawing.html">hyperspy.drawing package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.io_plugins.html">hyperspy.io_plugins package</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="hyperspy.learn.html">hyperspy.learn package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.misc.html">hyperspy.misc package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.models.html">hyperspy.models package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.samfire_utils.html">hyperspy.samfire_utils package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.utils.html">hyperspy.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Credits and citation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing HyperSpy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HyperSpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">hyperspy</a> &raquo;</li>
        
          <li><a href="hyperspy.html">hyperspy package</a> &raquo;</li>
        
          <li><a href="hyperspy.learn.html">hyperspy.learn package</a> &raquo;</li>
        
      <li>hyperspy.learn.mva module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/hyperspy.learn.mva.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-hyperspy.learn.mva">
<span id="hyperspy-learn-mva-module"></span><h1>hyperspy.learn.mva module<a class="headerlink" href="#module-hyperspy.learn.mva" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="hyperspy.learn.mva.LearningResults">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.learn.mva.</code><code class="sig-name descname">LearningResults</code><a class="headerlink" href="#hyperspy.learn.mva.LearningResults" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Stores the parameters and results from a decomposition.</p>
<dl class="method">
<dt id="hyperspy.learn.mva.LearningResults.crop_decomposition_dimension">
<code class="sig-name descname">crop_decomposition_dimension</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">compute=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.LearningResults.crop_decomposition_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop the score matrix up to the given number.</p>
<p>It is mainly useful to save memory and reduce the storage size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Number of components to keep.</p></li>
<li><p><strong>compute</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – If True and the decomposition results are lazy,
also compute the results.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.LearningResults.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.LearningResults.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the results of a previous decomposition and demixing analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>string</em>) – Path to load the results from.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.LearningResults.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">overwrite=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.LearningResults.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the result of the decomposition and demixing analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>string</em>) – Path to save the results to.</p></li>
<li><p><strong>overwrite</strong> (<em>{True</em><em>, </em><em>False</em><em>, </em><em>None}</em><em>, </em><em>default None</em>) – If True, overwrite the file if it exists.
If None (default), prompt user if file exists.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.LearningResults.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.LearningResults.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Summarize the decomposition and demixing parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>String summarizing the learning parameters.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy.learn.mva.MVA">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.learn.mva.</code><code class="sig-name descname">MVA</code><a class="headerlink" href="#hyperspy.learn.mva.MVA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Multivariate analysis capabilities for the Signal1D class.</p>
<dl class="method">
<dt id="hyperspy.learn.mva.MVA._calculate_recmatrix">
<code class="sig-name descname">_calculate_recmatrix</code><span class="sig-paren">(</span><em class="sig-param">components=None</em>, <em class="sig-param">mva_type='decomposition'</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._calculate_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuilds data from selected components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, or </em><em>list of ints</em>) – <ul>
<li><p>If None, rebuilds signal instance from all components</p></li>
<li><p>If int, rebuilds signal instance from components in range 0-given int</p></li>
<li><p>If list of ints, rebuilds signal instance from only components in given list</p></li>
</ul>
</p></li>
<li><p><strong>mva_type</strong> (<em>str {'decomposition'</em><em>, </em><em>'bss'}</em>) – Decomposition type (not case sensitive)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Data built from the given components.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._cluster_analysis">
<code class="sig-name descname">_cluster_analysis</code><span class="sig-paren">(</span><em class="sig-param">scaled_data</em>, <em class="sig-param">algorithm</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._cluster_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster analysis of a scaled data - internal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_clusters</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Number of clusters to find.</p></li>
<li><p><strong>scaled_data</strong> (<em>numpy array -</em><em> (</em><em>number_of_samples</em><em>,</em><em>number_of_features</em><em>)</em>) – </p></li>
<li><p><strong>algorithm</strong> (<em>scikit learn clustering object</em>) – </p></li>
<li><p><strong>**kwargs</strong> – Additional parameters passed to the clustering algorithm.
This may include <cite>n_init</cite>, the number of times the algorithm is
restarted to optimize results.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>return the sklearn.cluster object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>alg</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._distances_within_cluster">
<code class="sig-name descname">_distances_within_cluster</code><span class="sig-paren">(</span><em class="sig-param">cluster_data</em>, <em class="sig-param">memberships</em>, <em class="sig-param">squared=True</em>, <em class="sig-param">summed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._distances_within_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inter cluster distances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_data</strong> (<em>ndarray</em>) – scaled cluster data</p></li>
<li><p><strong>memberships</strong> (<em>ndarray</em>) – cluster labels</p></li>
<li><p><strong>squared</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>optional</em>) – square distance measurement. The default is True.</p></li>
<li><p><strong>summed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>optional</em>) – If False returns array showing sum of distance from a given point
to all other points in the cluster.
If True returns a sum of all distances within a cluster.
The results are scaled by 2*number of cluster points.
The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – list of distances for within the cluster</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._get_cluster_algorithm">
<code class="sig-name descname">_get_cluster_algorithm</code><span class="sig-paren">(</span><em class="sig-param">algorithm</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._get_cluster_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to lookup cluster algorithm if algorithm is a string
and instantiates it with n_clusters or if it’s an object check that
the object has a fit method</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._get_cluster_preprocessing_algorithm">
<code class="sig-name descname">_get_cluster_preprocessing_algorithm</code><span class="sig-paren">(</span><em class="sig-param">algorithm</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._get_cluster_preprocessing_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to lookup method if algorithm is a string
or if it’s an object check that the object has a fit_transform method</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._get_cluster_signal">
<code class="sig-name descname">_get_cluster_signal</code><span class="sig-paren">(</span><em class="sig-param">cluster_source</em>, <em class="sig-param">number_of_components=None</em>, <em class="sig-param">navigation_mask=None</em>, <em class="sig-param">signal_mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._get_cluster_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A cluster source can be an external signal, the signal data
or the decomposition or bss results
Return a flatten version of the data, nav and signal mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_source</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a><em> or </em><a class="reference internal" href="hyperspy.signal.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><em>BaseSignal</em></a>) – “decomposition”, “bss”, “signal” or a Signal</p></li>
<li><p><strong>number_of_components</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>optional</em>) – Number of components to use with decomposition sources.
The default is None.</p></li>
<li><p><strong>navigation_mask</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – mask used to select regions of the cluster_source to use.
The default is None.</p></li>
<li><p><strong>signal_mask</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – mask used to select regions of the cluster_source signal.
For decomposition or bss this is not used.
The default is None.</p></li>
<li><p><strong>reproject</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>optional</em>) – If False the and the cluster_source is decomposition or bss
the loadings are returned. If True the factor &#64; loadings result
is used. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>toreturn</strong> – Returns an unfolded dataset from
the selected cluster_source</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._get_number_of_components_for_clustering">
<code class="sig-name descname">_get_number_of_components_for_clustering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._get_number_of_components_for_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of components</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA._scale_data_for_clustering">
<code class="sig-name descname">_scale_data_for_clustering</code><span class="sig-paren">(</span><em class="sig-param">cluster_signal</em>, <em class="sig-param">preprocessing='norm'</em>, <em class="sig-param">preprocessing_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA._scale_data_for_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale data for cluster analysis</p>
<p>Results are stored in <cite>learning_results</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_signal</strong> (<em>{&quot;bss&quot;</em><em>, </em><em>&quot;decomposition&quot;</em><em>, </em><em>&quot;signal&quot;</em><em>, </em><em>Signal}</em>) – If “bss” the blind source separation results are used
If “decomposition” the decomposition results are used
if “signal” the signal data is used (signal should be unfolded)</p></li>
<li><p><strong>preprocessing</strong> (<em>{&quot;standard&quot;</em><em>,</em><em>&quot;norm&quot;</em><em>,</em><em>&quot;minmax&quot;</em><em>,</em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><em>scikit learn preprocessing method}</em>) – default: ‘norm’
Preprocessing the data before cluster analysis requires preprocessing
the data to be clustered to similar scales. Standard preprocessing
adjusts each feature to have uniform variation. Norm preprocessing
adjusts treats the set of features like a vector and
each measurement is scaled to length 1.
You can also pass a cikit-learn preprocessing object
See scaling methods in scikit-learn preprocessing for further
details.</p></li>
<li><p><strong>preprocessing_kwargs</strong> – Additional parameters passed to the cluster preprocessing algorithm.
See sklearn.preprocessing preprocessing methods for further details</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">clusters_analysis()</span></code>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.estimate_number_of_clusters" title="hyperspy.learn.mva.MVA.estimate_number_of_clusters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_number_of_clusters()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_labels()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_signals()</span></code>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_cluster_metric" title="hyperspy.learn.mva.MVA.plot_cluster_metric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_metric()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_results()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_signals()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_labels()</span></code></p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>scaled_data</strong> (<em>numpy array - unfolded array of shape (number_of_samples,</em>)</p></li>
<li><p><em>no_of_features) scaled according to the selected algorithm</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.blind_source_separation">
<code class="sig-name descname">blind_source_separation</code><span class="sig-paren">(</span><em class="sig-param">number_of_components=None</em>, <em class="sig-param">algorithm='sklearn_fastica'</em>, <em class="sig-param">diff_order=1</em>, <em class="sig-param">diff_axes=None</em>, <em class="sig-param">factors=None</em>, <em class="sig-param">comp_list=None</em>, <em class="sig-param">mask=None</em>, <em class="sig-param">on_loadings=False</em>, <em class="sig-param">reverse_component_criterion='factors'</em>, <em class="sig-param">whiten_method='PCA'</em>, <em class="sig-param">return_info=False</em>, <em class="sig-param">print_info=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.blind_source_separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply blind source separation (BSS) to the result of a decomposition.</p>
<p>The results are stored in <code class="docutils literal notranslate"><span class="pre">self.learning_results</span></code>.</p>
<p>Read more in the <a class="reference internal" href="../user_guide/mva.html#mva-blind-source-separation"><span class="std std-ref">User Guide</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_components</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a>) – Number of principal components to pass to the BSS algorithm.
If None, you must specify the <code class="docutils literal notranslate"><span class="pre">comp_list</span></code> argument.</p></li>
<li><p><strong>algorithm</strong> (<em>{&quot;sklearn_fastica&quot;</em><em>, </em><em>&quot;orthomax&quot;</em><em>, </em><em>&quot;FastICA&quot;</em><em>, </em><em>&quot;JADE&quot;</em><em>, </em><em>&quot;CuBICA&quot;</em><em>, </em><em>&quot;TDSEP&quot;</em><em>, </em><em>custom object}</em><em>, </em><em>default &quot;sklearn_fastica&quot;</em>) – The BSS algorithm to use. If algorithm is an object,
it must implement a <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> method or <code class="docutils literal notranslate"><span class="pre">fit()</span></code> and
<code class="docutils literal notranslate"><span class="pre">transform()</span></code> methods, in the same manner as a scikit-learn estimator.</p></li>
<li><p><strong>diff_order</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>default 1</em>) – Sometimes it is convenient to perform the BSS on the derivative of
the signal. If <code class="docutils literal notranslate"><span class="pre">diff_order</span></code> is 0, the signal is not differentiated.</p></li>
<li><p><strong>diff_axes</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><em>list of ints</em><em> or </em><em>strings</em>) – <ul>
<li><p>If None and <cite>on_loadings</cite> is False, when <cite>diff_order</cite> is greater than 1
and <cite>signal_dimension</cite> is greater than 1, the differences are calculated
across all signal axes</p></li>
<li><p>If None and <cite>on_loadings</cite> is True, when <cite>diff_order</cite> is greater than 1
and <cite>navigation_dimension</cite> is greater than 1, the differences are calculated
across all navigation axes</p></li>
<li><p>Otherwise the axes can be specified in a list.</p></li>
</ul>
</p></li>
<li><p><strong>factors</strong> (<a class="reference internal" href="hyperspy.signal.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSignal</span></code></a> or numpy array) – Factors to decompose. If None, the BSS is performed on the
factors of a previous decomposition. If a Signal instance, the
navigation dimension must be 1 and the size greater than 1.</p></li>
<li><p><strong>comp_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a><em> or </em><em>numpy array</em>) – Choose the components to apply BSS to. Unlike <code class="docutils literal notranslate"><span class="pre">number_of_components</span></code>,
this argument permits non-contiguous components.</p></li>
<li><p><strong>mask</strong> (<a class="reference internal" href="hyperspy.signal.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSignal</span></code></a> or subclass) – If not None, the signal locations marked as True are masked. The
mask shape must be equal to the signal shape
(navigation shape) when <cite>on_loadings</cite> is False (True).</p></li>
<li><p><strong>on_loadings</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – If True, perform the BSS on the loadings of a previous
decomposition, otherwise, perform the BSS on the factors.</p></li>
<li><p><strong>reverse_component_criterion</strong> (<em>{&quot;factors&quot;</em><em>, </em><em>&quot;loadings&quot;}</em><em>, </em><em>default &quot;factors&quot;</em>) – Use either the factors or the loadings to determine if the
component needs to be reversed.</p></li>
<li><p><strong>whiten_method</strong> (<em>{&quot;PCA&quot;</em><em>, </em><em>&quot;ZCA&quot;</em><em>, </em><em>None}</em><em>, </em><em>default &quot;PCA&quot;</em>) – How to whiten the data prior to blind source separation.
If None, no whitening is applied. See <a class="reference internal" href="hyperspy.learn.whitening.html#hyperspy.learn.whitening.whiten_data" title="hyperspy.learn.whitening.whiten_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">whiten_data()</span></code></a>
for more details.</p></li>
<li><p><strong>return_info</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – The result of the decomposition is stored internally. However,
some algorithms generate some extra information that is not
stored. If True, return any extra information if available.
In the case of sklearn.decomposition objects, this includes the
sklearn Estimator object.</p></li>
<li><p><strong>print_info</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default True</em>) – If True, print information about the decomposition being performed.
In the case of sklearn.decomposition objects, this includes the
values of all arguments of the chosen sklearn algorithm.</p></li>
<li><p><strong>**kwargs</strong> (<em>extra keyword arguments</em>) – Any keyword arguments are passed to the BSS algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>return_info</strong> –</p>
<ul class="simple">
<li><p>If True and ‘algorithm’ is an sklearn Estimator, returns the
Estimator object.</p></li>
<li><p>Otherwise, returns None</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.Estimator or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_factors()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_loadings()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_results()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.cluster_analysis">
<code class="sig-name descname">cluster_analysis</code><span class="sig-paren">(</span><em class="sig-param">cluster_source</em>, <em class="sig-param">source_for_centers=None</em>, <em class="sig-param">preprocessing=None</em>, <em class="sig-param">preprocessing_kwargs={}</em>, <em class="sig-param">number_of_components=None</em>, <em class="sig-param">navigation_mask=None</em>, <em class="sig-param">signal_mask=None</em>, <em class="sig-param">algorithm=None</em>, <em class="sig-param">return_info=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.cluster_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster analysis of a signal or decomposition results of a signal
Results are stored in <cite>learning_results</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_source</strong> (<em>{&quot;bss&quot;</em><em>, </em><em>&quot;decomposition&quot;</em><em>, </em><em>&quot;signal&quot;</em><em>, </em><em>BaseSignal}</em>) – If “bss” the blind source separation results are used
If “decomposition” the decomposition results are used
if “signal” the signal data is used
Note that using the signal or BaseSignal can be memory intensive
and is only recommended if the Signal dimension is small
BaseSignal must have the same navigation dimensions as the signal.</p></li>
<li><p><strong>source_for_centers</strong> (<em>{None</em><em>,</em><em>&quot;decomposition&quot;</em><em>,</em><em>&quot;bss&quot;</em><em>,</em><em>&quot;signal&quot;</em><em>,</em><em>BaseSignal}</em><em>,</em>) – default : None
If None the cluster_source is used
If “bss” the blind source separation results are used
If “decomposition” the decomposition results are used
if “signal” the signal data is used
BaseSignal must have the same navigation dimensions as the signal.</p></li>
<li><p><strong>preprocessing</strong> (<em>{&quot;standard&quot;</em><em>,</em><em>&quot;norm&quot;</em><em>,</em><em>&quot;minmax&quot;</em><em>,</em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><em>scikit learn preprocessing method}</em>) – default: ‘norm’
Preprocessing the data before cluster analysis requires preprocessing
the data to be clustered to similar scales. Standard preprocessing
adjusts each feature to have uniform variation. Norm preprocessing
adjusts treats the set of features like a vector and
each measurement is scaled to length 1.
You can also pass one of the scikit-learn preprocessing
scale_method = import sklearn.processing.StandadScaler()
preprocessing = scale_method
See preprocessing methods in scikit-learn preprocessing for further
details.</p></li>
<li><p><strong>preprocessing_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a>) – Additional parameters passed to the supported sklearn preprocessing methods.
See sklearn.preprocessing scaling methods for further details</p></li>
<li><p><strong>number_of_components</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>default None</em>) – If you are getting the cluster centers using the decomposition
results (cluster_source_for_centers=”decomposition”) you can define how
many components to use.  If set to None the method uses the
estimate of significant components found in the decomposition step
using the elbow method and stored in the
<code class="docutils literal notranslate"><span class="pre">learning_results.number_significant_components</span></code> attribute.
This applies to both bss and decomposition results.</p></li>
<li><p><strong>navigation_mask</strong> (<em>boolean numpy array</em>) – The navigation locations marked as True are not used.</p></li>
<li><p><strong>signal_mask</strong> (<em>boolean numpy array</em>) – The signal locations marked as True are not used in the
clustering for “signal” or Signals supplied as cluster source.
This is not applied to decomposition results or source_for_centers
(as it may be a different shape to the cluster source)</p></li>
<li><p><strong>algorithm</strong> (<em>{ &quot;kmeans&quot; | &quot;agglomerative&quot; | &quot;minibatchkmeans&quot; | &quot;spectralclustering&quot;}</em>) – See scikit-learn documentation. Default “kmeans”</p></li>
<li><p><strong>return_info</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – The result of the cluster analysis is stored internally. However,
the cluster class used  contain a number of attributes.
If True (the default is False)
return the cluster object so the attributes can be accessed.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict  optional</em><em>, </em><em>default - empty</em>) – Additional parameters passed to the clustering class for initialization.
For example, in case of the “kmeans” algorithm, <cite>n_init</cite> can be
used to define the number of times the algorithm is restarted to
optimize results.</p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>n_clusters</strong> (<em>int</em>) – Number of clusters to find using the one of the pre-defined methods
“kmeans”,”agglomerative”,”minibatchkmeans”,”spectralclustering”
See sklearn.cluster for details</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.estimate_number_of_clusters" title="hyperspy.learn.mva.MVA.estimate_number_of_clusters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_number_of_clusters()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_labels()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_signals()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_distances()</span></code>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_cluster_metric" title="hyperspy.learn.mva.MVA.plot_cluster_metric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_metric()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_results()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_signals()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_labels()</span></code></p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>If ‘return_info’ is True returns the Scikit-learn cluster object</em></p></li>
<li><p><em>used for clustering. Useful if you wish to</em></p></li>
<li><p><em>examine inertia or other outputs.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.decomposition">
<code class="sig-name descname">decomposition</code><span class="sig-paren">(</span><em class="sig-param">normalize_poissonian_noise=False</em>, <em class="sig-param">algorithm='SVD'</em>, <em class="sig-param">output_dimension=None</em>, <em class="sig-param">centre=None</em>, <em class="sig-param">auto_transpose=True</em>, <em class="sig-param">navigation_mask=None</em>, <em class="sig-param">signal_mask=None</em>, <em class="sig-param">var_array=None</em>, <em class="sig-param">var_func=None</em>, <em class="sig-param">reproject=None</em>, <em class="sig-param">return_info=False</em>, <em class="sig-param">print_info=True</em>, <em class="sig-param">svd_solver='auto'</em>, <em class="sig-param">copy=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a decomposition to a dataset with a choice of algorithms.</p>
<p>The results are stored in <code class="docutils literal notranslate"><span class="pre">self.learning_results</span></code>.</p>
<p>Read more in the <a class="reference internal" href="../user_guide/mva.html#mva-decomposition"><span class="std std-ref">User Guide</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normalize_poissonian_noise</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – If True, scale the signal to normalize Poissonian noise using
the approach described in <a class="reference internal" href="#keenan2004" id="id1"><span>[Keenan2004]</span></a>.</p></li>
<li><p><strong>algorithm</strong> (<em>{&quot;SVD&quot;</em><em>, </em><em>&quot;MLPCA&quot;</em><em>, </em><em>&quot;sklearn_pca&quot;</em><em>, </em><em>&quot;NMF&quot;</em><em>, </em><em>&quot;sparse_pca&quot;</em><em>, </em><em>&quot;mini_batch_sparse_pca&quot;</em><em>, </em><em>&quot;RPCA&quot;</em><em>, </em><em>&quot;ORPCA&quot;</em><em>, </em><em>&quot;ORNMF&quot;</em><em>, </em><em>custom object}</em><em>, </em><em>default &quot;SVD&quot;</em>) – The decomposition algorithm to use. If algorithm is an object,
it must implement a <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> method or <code class="docutils literal notranslate"><span class="pre">fit()</span></code> and
<code class="docutils literal notranslate"><span class="pre">transform()</span></code> methods, in the same manner as a scikit-learn estimator.</p></li>
<li><p><strong>output_dimension</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Number of components to keep/calculate.
Default is None, i.e. <code class="docutils literal notranslate"><span class="pre">min(data.shape)</span></code>.</p></li>
<li><p><strong>centre</strong> (<em>{None</em><em>, </em><em>&quot;navigation&quot;</em><em>, </em><em>&quot;signal&quot;}</em><em>, </em><em>default None</em>) – <ul>
<li><p>If None, the data is not centered prior to decomposition.</p></li>
<li><p>If “navigation”, the data is centered along the navigation axis.
Only used by the “SVD” algorithm.</p></li>
<li><p>If “signal”, the data is centered along the signal axis.
Only used by the “SVD” algorithm.</p></li>
</ul>
</p></li>
<li><p><strong>auto_transpose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default True</em>) – If True, automatically transposes the data to boost performance.
Only used by the “SVD” algorithm.</p></li>
<li><p><strong>navigation_mask</strong> (<em>boolean numpy array</em><em> or </em><a class="reference internal" href="hyperspy.signal.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><em>BaseSignal</em></a>) – The navigation locations marked as True are not used in the
decomposition.</p></li>
<li><p><strong>signal_mask</strong> (<em>boolean numpy array</em><em> or </em><a class="reference internal" href="hyperspy.signal.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><em>BaseSignal</em></a>) – The signal locations marked as True are not used in the
decomposition.</p></li>
<li><p><strong>var_array</strong> (<em>numpy array</em>) – Array of variance for the maximum likelihood PCA algorithm.
Only used by the “MLPCA” algorithm.</p></li>
<li><p><strong>var_func</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a><em> or </em><em>function</em><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – <ul>
<li><p>If None, ignored</p></li>
<li><p>If function, applies the function to the data to obtain <code class="docutils literal notranslate"><span class="pre">var_array</span></code>.
Only used by the “MLPCA” algorithm.</p></li>
<li><p>If numpy array, creates <code class="docutils literal notranslate"><span class="pre">var_array</span></code> by applying a polynomial function
defined by the array of coefficients to the data. Only used by
the “MLPCA” algorithm.</p></li>
</ul>
</p></li>
<li><p><strong>reproject</strong> (<em>{None</em><em>, </em><em>&quot;signal&quot;</em><em>, </em><em>&quot;navigation&quot;</em><em>, </em><em>&quot;both&quot;}</em><em>, </em><em>default None</em>) – If not None, the results of the decomposition will be projected in
the selected masked area.</p></li>
<li><p><strong>return_info</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – The result of the decomposition is stored internally. However,
some algorithms generate some extra information that is not
stored. If True, return any extra information if available.
In the case of sklearn.decomposition objects, this includes the
sklearn Estimator object.</p></li>
<li><p><strong>print_info</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default True</em>) – If True, print information about the decomposition being performed.
In the case of sklearn.decomposition objects, this includes the
values of all arguments of the chosen sklearn algorithm.</p></li>
<li><p><strong>svd_solver</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>&quot;full&quot;</em><em>, </em><em>&quot;arpack&quot;</em><em>, </em><em>&quot;randomized&quot;}</em><em>, </em><em>default &quot;auto&quot;</em>) – <dl class="simple">
<dt>If auto:</dt><dd><p>The solver is selected by a default policy based on <cite>data.shape</cite> and
<cite>output_dimension</cite>: if the input data is larger than 500x500 and the
number of components to extract is lower than 80% of the smallest
dimension of the data, then the more efficient “randomized”
method is enabled. Otherwise the exact full SVD is computed and
optionally truncated afterwards.</p>
</dd>
<dt>If full:</dt><dd><p>run exact SVD, calling the standard LAPACK solver via
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.linalg.svd.html#scipy.linalg.svd" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.linalg.svd()</span></code></a>, and select the components by postprocessing</p>
</dd>
<dt>If arpack:</dt><dd><p>use truncated SVD, calling ARPACK solver via
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.sparse.linalg.svds.html#scipy.sparse.linalg.svds" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.svds()</span></code></a>. It requires strictly
<cite>0 &lt; output_dimension &lt; min(data.shape)</cite></p>
</dd>
<dt>If randomized:</dt><dd><p>use truncated SVD, calling <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd" title="(in scikit-learn v0.24)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.utils.extmath.randomized_svd()</span></code></a>
to estimate a limited number of components</p>
</dd>
</dl>
</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default True</em>) – <ul>
<li><p>If True, stores a copy of the data before any pre-treatments
such as normalization in <code class="docutils literal notranslate"><span class="pre">s._data_before_treatments</span></code>. The original
data can then be restored by calling <code class="docutils literal notranslate"><span class="pre">s.undo_treatments()</span></code>.</p></li>
<li><p>If False, no copy is made. This can be beneficial for memory
usage, but care must be taken since data will be overwritten.</p></li>
</ul>
</p></li>
<li><p><strong>**kwargs</strong> (<em>extra keyword arguments</em>) – Any keyword arguments are passed to the decomposition algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>return_info</strong> –</p>
<ul class="simple">
<li><p>If True and ‘algorithm’ in [‘RPCA’, ‘ORPCA’, ‘ORNMF’], returns
the low-rank (X) and sparse (E) matrices from robust PCA/NMF.</p></li>
<li><p>If True and ‘algorithm’ is an sklearn Estimator, returns the
Estimator object.</p></li>
<li><p>Otherwise, returns None</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a>(numpy array, numpy array) or sklearn.Estimator or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="keenan2004"><span class="brackets">Keenan2004</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>M. Keenan and P. Kotula, “Accounting for Poisson noise
in the multivariate analysis of ToF-SIMS spectrum images”, Surf.
Interface Anal 36(3) (2004): 203-212.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_factors()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_loadings()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_results()</span></code></p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_explained_variance_ratio" title="hyperspy.learn.mva.MVA.plot_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_explained_variance_ratio()</span></code></a></p></li>
<li><p><a class="reference internal" href="hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.decomposition" title="hyperspy._signals.lazy.LazySignal.decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomposition()</span></code></a> for lazy signals</p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.estimate_elbow_position">
<code class="sig-name descname">estimate_elbow_position</code><span class="sig-paren">(</span><em class="sig-param">explained_variance_ratio=None</em>, <em class="sig-param">log=True</em>, <em class="sig-param">max_points=20</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.estimate_elbow_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the elbow position of a scree plot curve.</p>
<p>Used to estimate the number of significant components in
a PCA variance ratio plot or other “elbow” type curves.</p>
<p>Find a line between first and last point on the scree plot.
With a classic elbow scree plot, this line more or less
defines a triangle. The elbow should be the point which
is the furthest distance from this line. For more details,
see <a class="reference internal" href="#satopaa2011" id="id2"><span>[Satopää2011]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>explained_variance_ratio</strong> (<em>{None</em><em>, </em><em>numpy array}</em>) – Explained variance ratio values that form the scree plot.
If None, uses the <code class="docutils literal notranslate"><span class="pre">explained_variance_ratio</span></code> array stored
in <code class="docutils literal notranslate"><span class="pre">s.learning_results</span></code>, so a decomposition must have
been performed first.</p></li>
<li><p><strong>max_points</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Maximum number of points to consider in the calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>elbow position</strong> – Index of the elbow position in the input array. Due to
zero-based indexing, the number of significant components
is <cite>elbow_position + 1</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="satopaa2011"><span class="brackets"><a class="fn-backref" href="#id2">Satopää2011</a></span></dt>
<dd><p>V. Satopää, J. Albrecht, D. Irwin, and B. Raghavan.
“Finding a “Kneedle” in a Haystack: Detecting Knee Points in
System Behavior,. 31st International Conference on Distributed
Computing Systems Workshops, pp. 166-171, June 2011.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.get_explained_variance_ratio" title="hyperspy.learn.mva.MVA.get_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_explained_variance_ratio()</span></code></a>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_explained_variance_ratio" title="hyperspy.learn.mva.MVA.plot_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_explained_variance_ratio()</span></code></a>,</p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.estimate_number_of_clusters">
<code class="sig-name descname">estimate_number_of_clusters</code><span class="sig-paren">(</span><em class="sig-param">cluster_source</em>, <em class="sig-param">max_clusters=10</em>, <em class="sig-param">preprocessing=None</em>, <em class="sig-param">preprocessing_kwargs={}</em>, <em class="sig-param">number_of_components=None</em>, <em class="sig-param">navigation_mask=None</em>, <em class="sig-param">signal_mask=None</em>, <em class="sig-param">algorithm=None</em>, <em class="sig-param">metric='gap'</em>, <em class="sig-param">n_ref=4</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.estimate_number_of_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs cluster analysis of a signal for cluster sizes ranging from
n_clusters =2 to max_clusters ( default 12)
Note that this can be a slow process for large datasets so please
consider reducing max_clusters in this case.
For each cluster it evaluates the silhouette score which is a metric of
how well separated the clusters are. Maximima or peaks in the scores
indicate good choices for cluster sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_source</strong> (<em>{&quot;bss&quot;</em><em>, </em><em>&quot;decomposition&quot;</em><em>, </em><em>&quot;signal&quot;</em><em> or </em><em>Signal}</em>) – If “bss” the blind source separation results are used
If “decomposition” the decomposition results are used
if “signal” the signal data is used
Note that using the signal can be memory intensive
and is only recommended if the Signal dimension is small.
Input Signal must have the same navigation dimensions as the
signal instance.</p></li>
<li><p><strong>max_clusters</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>default 10</em>) – Max number of clusters to use. The method will scan from 2 to
max_clusters.</p></li>
<li><p><strong>preprocessing</strong> (<em>{&quot;standard&quot;</em><em>,</em><em>&quot;norm&quot;</em><em>,</em><em>&quot;minmax&quot;</em><em> or </em><em>sklearn-like preprocessing object}</em>) – default: ‘norm’
Preprocessing the data before cluster analysis requires preprocessing
the data to be clustered to similar scales. Standard preprocessing
adjusts each feature to have uniform variation. Norm preprocessing
adjusts treats the set of features like a vector and
each measurement is scaled to length 1.
You can also pass an instance of a sklearn preprocessing module.
See preprocessing methods in scikit-learn preprocessing for further
details.</p></li>
<li><p><strong>preprocessing_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a><em>, </em><em>default empty</em>) – Additional parameters passed to the cluster preprocessing algorithm.
See sklearn.preprocessing preprocessing methods for further details</p></li>
<li><p><strong>number_of_components</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>default None</em>) – If you are getting the cluster centers using the decomposition
results (cluster_source_for_centers=”decomposition”) you can define how
many PCA components to use. If set to None the method uses the
estimate of significant components found in the decomposition step
using the elbow method and stored in the
<code class="docutils literal notranslate"><span class="pre">learning_results.number_significant_components</span></code> attribute.</p></li>
<li><p><strong>navigation_mask</strong> (<em>boolean numpy array</em><em>, </em><em>default : None</em>) – The navigation locations marked as True are not used in the
clustering.</p></li>
<li><p><strong>signal_mask</strong> (<em>boolean numpy array</em><em>, </em><em>default : None</em>) – The signal locations marked as True are not used in the
clustering. Applies to “signal” or Signal cluster sources only.</p></li>
<li><p><strong>metric</strong> (<em>{'elbow'</em><em>,</em><em>'silhouette'</em><em>,</em><em>'gap'} default 'gap'</em>) – Use distance,silhouette analysis or gap statistics to estimate
the optimal number of clusters.
Gap is believed to be, overall, the best metric but it’s also
the slowest. Elbow measures the distances between points in
each cluster as an estimate of how well grouped they are and
is the fastest metric.
For elbow the optimal k is the knee or elbow point.
For gap the optimal k is the first k gap(k)&gt;= gap(k+1)-std_error
For silhouette the optimal k will be one of the “maxima” found with
this method</p></li>
<li><p><strong>n_ref</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>default 4</em>) – Number of references to use in gap statistics method
Gap statistics compares the results from clustering the data to
clustering uniformly distributed data. As clustering has
a random variation it is typically averaged n_ref times
to get an statistical average</p></li>
<li><p><strong>**kwargs</strong> (<em>dict {}  default empty</em>) – Parameters passed to the clustering algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>n_clusters</strong> (<em>int</em>) – Number of clusters to find using the one of the pre-defined methods
“kmeans”,”agglomerative”,”minibatchkmeans”,”spectralclustering”
See sklearn.cluster for details</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>best_k</strong> – Estimate of the best cluster size</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.cluster_analysis" title="hyperspy.learn.mva.MVA.cluster_analysis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cluster_analysis()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_labels()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_signals()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_distances()</span></code>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_cluster_metric" title="hyperspy.learn.mva.MVA.plot_cluster_metric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_metric()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_results()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_signals()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_labels()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.get_bss_model">
<code class="sig-name descname">get_bss_model</code><span class="sig-paren">(</span><em class="sig-param">components=None</em>, <em class="sig-param">chunks='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.get_bss_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate model with the selected number of independent components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>components</strong> (<em>{None</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>list of ints}</em><em>, </em><em>default None</em>) – <ul class="simple">
<li><p>If None, rebuilds signal instance from all components</p></li>
<li><p>If int, rebuilds signal instance from components in range 0-given int</p></li>
<li><p>If list of ints, rebuilds signal instance from only components in given list</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A model built from the given components.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.get_decomposition_model">
<code class="sig-name descname">get_decomposition_model</code><span class="sig-paren">(</span><em class="sig-param">components=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.get_decomposition_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate model with the selected number of principal components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>components</strong> (<em>{None</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><em>list of ints}</em><em>, </em><em>default None</em>) – <ul class="simple">
<li><p>If None, rebuilds signal instance from all components</p></li>
<li><p>If int, rebuilds signal instance from components in range 0-given int</p></li>
<li><p>If list of ints, rebuilds signal instance from only components in given list</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A model built from the given components.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.get_explained_variance_ratio">
<code class="sig-name descname">get_explained_variance_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.get_explained_variance_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return explained variance ratio of the PCA components as a Signal1D.</p>
<p>Read more in the <a class="reference internal" href="../user_guide/mva.html#mva-scree-plot"><span class="std std-ref">User Guide</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>s</strong> – Explained variance ratio.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hyperspy._signals.signal1d.html#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D">Signal1D</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.decomposition" title="hyperspy.learn.mva.MVA.decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomposition()</span></code></a></p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_explained_variance_ratio" title="hyperspy.learn.mva.MVA.plot_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_explained_variance_ratio()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_loadings()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_factors()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.normalize_bss_components">
<code class="sig-name descname">normalize_bss_components</code><span class="sig-paren">(</span><em class="sig-param">target='factors'</em>, <em class="sig-param">function=&lt;function sum&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.normalize_bss_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize BSS components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>{&quot;factors&quot;</em><em>, </em><em>&quot;loadings&quot;}</em>) – Normalize components based on the scale of either the factors or loadings.</p></li>
<li><p><strong>function</strong> (<em>numpy universal function</em><em>, </em><em>default np.sum</em>) – Each target component is divided by the output of <code class="docutils literal notranslate"><span class="pre">function(target)</span></code>.
The function must return a scalar when operating on numpy arrays and
must have an <cite>axis</cite> argument.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.normalize_decomposition_components">
<code class="sig-name descname">normalize_decomposition_components</code><span class="sig-paren">(</span><em class="sig-param">target='factors'</em>, <em class="sig-param">function=&lt;function sum&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.normalize_decomposition_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize decomposition components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>{&quot;factors&quot;</em><em>, </em><em>&quot;loadings&quot;}</em>) – Normalize components based on the scale of either the factors or loadings.</p></li>
<li><p><strong>function</strong> (<em>numpy universal function</em><em>, </em><em>default np.sum</em>) – Each target component is divided by the output of <code class="docutils literal notranslate"><span class="pre">function(target)</span></code>.
The function must return a scalar when operating on numpy arrays and
must have an <cite>axis</cite> argument.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.normalize_poissonian_noise">
<code class="sig-name descname">normalize_poissonian_noise</code><span class="sig-paren">(</span><em class="sig-param">navigation_mask=None</em>, <em class="sig-param">signal_mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.normalize_poissonian_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the signal under the assumption of Poisson noise.</p>
<p>Scales the signal using to “normalize” the Poisson data for
subsequent decomposition analysis <a class="reference internal" href="#keenan2004" id="id3"><span>[Keenan2004]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>navigation_mask</strong> (<em>{None</em><em>, </em><em>boolean numpy array}</em><em>, </em><em>default None</em>) – Optional mask applied in the navigation axis.</p></li>
<li><p><strong>signal_mask</strong> (<em>{None</em><em>, </em><em>boolean numpy array}</em><em>, </em><em>default None</em>) – Optional mask applied in the signal axis.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.plot_cluster_metric">
<code class="sig-name descname">plot_cluster_metric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.plot_cluster_metric" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Plot the cluster metrics calculated</dt><dd><p>using evaluate_number_of_clusters method</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.estimate_number_of_clusters" title="hyperspy.learn.mva.MVA.estimate_number_of_clusters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_number_of_clusters()</span></code></a>,</p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.cluster_analysis" title="hyperspy.learn.mva.MVA.cluster_analysis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cluster_analysis()</span></code></a>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_labels()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cluster_signals()</span></code>,</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_results()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_signals()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_cluster_labels()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.plot_cumulative_explained_variance_ratio">
<code class="sig-name descname">plot_cumulative_explained_variance_ratio</code><span class="sig-paren">(</span><em class="sig-param">n=50</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.plot_cumulative_explained_variance_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot cumulative explained variance up to n principal components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Number of principal components to show.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ax</strong> – Axes object containing the cumulative explained variance plot.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.axes</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.learn.mva.MVA.plot_explained_variance_ratio" title="hyperspy.learn.mva.MVA.plot_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_explained_variance_ratio()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.plot_explained_variance_ratio">
<code class="sig-name descname">plot_explained_variance_ratio</code><span class="sig-paren">(</span><em class="sig-param">n=30</em>, <em class="sig-param">log=True</em>, <em class="sig-param">threshold=0</em>, <em class="sig-param">hline='auto'</em>, <em class="sig-param">vline=False</em>, <em class="sig-param">xaxis_type='index'</em>, <em class="sig-param">xaxis_labeling=None</em>, <em class="sig-param">signal_fmt=None</em>, <em class="sig-param">noise_fmt=None</em>, <em class="sig-param">fig=None</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.plot_explained_variance_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the decomposition explained variance ratio vs index number.</p>
<p>This is commonly known as a scree plot.</p>
<p>Read more in the <a class="reference internal" href="../user_guide/mva.html#mva-scree-plot"><span class="std std-ref">User Guide</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a>) – Number of components to plot. If None, all components will be plot</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default True</em>) – If True, the y axis uses a log scale.</p></li>
<li><p><strong>threshold</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – Threshold used to determine how many components should be
highlighted as signal (as opposed to noise).
If a float (between 0 and 1), <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be
interpreted as a cutoff value, defining the variance at which to
draw a line showing the cutoff between signal and noise;
the number of signal components will be automatically determined
by the cutoff value.
If an int, <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is interpreted as the number of
components to highlight as signal (and no cutoff line will be
drawn)</p></li>
<li><p><strong>hline</strong> (<em>{'auto'</em><em>, </em><em>True</em><em>, </em><em>False}</em>) – Whether or not to draw a horizontal line illustrating the variance
cutoff for signal/noise determination. Default is to draw the line
at the value given in <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (if it is a float) and not
draw in the case  <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is an int, or not given.
If True, (and <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is an int), the line will be drawn
through the last component defined as signal.
If False, the line will not be drawn in any circumstance.</p></li>
<li><p><strong>vline</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><em>default False</em>) – Whether or not to draw a vertical line illustrating an estimate of
the number of significant components. If True, the line will be
drawn at the the knee or elbow position of the curve indicating the
number of significant components.
If False, the line will not be drawn in any circumstance.</p></li>
<li><p><strong>xaxis_type</strong> (<em>{'index'</em><em>, </em><em>'number'}</em>) – Determines the type of labeling applied to the x-axis.
If <code class="docutils literal notranslate"><span class="pre">'index'</span></code>, axis will be labeled starting at 0 (i.e.
“pythonic index” labeling); if <code class="docutils literal notranslate"><span class="pre">'number'</span></code>, it will start at 1
(number labeling).</p></li>
<li><p><strong>xaxis_labeling</strong> (<em>{'ordinal'</em><em>, </em><em>'cardinal'</em><em>, </em><em>None}</em>) – Determines the format of the x-axis tick labels. If <code class="docutils literal notranslate"><span class="pre">'ordinal'</span></code>,
“1st, 2nd, …” will be used; if <code class="docutils literal notranslate"><span class="pre">'cardinal'</span></code>, “1, 2,
…” will be used. If None, an appropriate default will be
selected.</p></li>
<li><p><strong>signal_fmt</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a>) – Dictionary of matplotlib formatting values for the signal
components</p></li>
<li><p><strong>noise_fmt</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a>) – Dictionary of matplotlib formatting values for the noise
components</p></li>
<li><p><strong>fig</strong> (<em>matplotlib figure</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a>) – If None, a default figure will be created, otherwise will plot
into fig</p></li>
<li><p><strong>ax</strong> (<em>matplotlib ax</em><em> (</em><em>subplot</em><em>) or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><em>None</em></a>) – If None, a default ax will be created, otherwise will plot into ax</p></li>
<li><p><strong>**kwargs</strong> – remaining keyword arguments are passed to <code class="docutils literal notranslate"><span class="pre">matplotlib.figure()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ax</strong> – Axes object containing the scree plot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.axes</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>To generate a scree plot with customized symbols for signal vs.
noise components and a modified cutoff threshold value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;some_spectrum_image&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">decomposition</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot_explained_variance_ratio</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                <span class="n">threshold</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                <span class="n">signal_fmt</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                            <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                            <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;pink&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span>                                <span class="n">noise_fmt</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                            <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                            <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.decomposition" title="hyperspy.learn.mva.MVA.decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomposition()</span></code></a></p></li>
<li><p><a class="reference internal" href="#hyperspy.learn.mva.MVA.get_explained_variance_ratio" title="hyperspy.learn.mva.MVA.get_explained_variance_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_explained_variance_ratio()</span></code></a></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_loadings()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_factors()</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.reverse_bss_component">
<code class="sig-name descname">reverse_bss_component</code><span class="sig-paren">(</span><em class="sig-param">component_number</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.reverse_bss_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the independent component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>component_number</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – component index/es</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_file&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">decomposition</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># perform PCA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">blind_source_separation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># perform ICA on 3 PCs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">reverse_bss_component</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># reverse IC 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">reverse_bss_component</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># reverse ICs 0 and 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.reverse_decomposition_component">
<code class="sig-name descname">reverse_decomposition_component</code><span class="sig-paren">(</span><em class="sig-param">component_number</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.reverse_decomposition_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the decomposition component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>component_number</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – component index/es</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_file&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">decomposition</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># perform PCA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">reverse_decomposition_component</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># reverse IC 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">reverse_decomposition_component</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># reverse ICs 0 and 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.learn.mva.MVA.undo_treatments">
<code class="sig-name descname">undo_treatments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva.MVA.undo_treatments" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo Poisson noise normalization and other pre-treatments.</p>
<p>Only valid if calling <code class="docutils literal notranslate"><span class="pre">s.decomposition(...,</span> <span class="pre">copy=True)</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hyperspy.learn.mva._get_derivative">
<code class="sig-prename descclassname">hyperspy.learn.mva.</code><code class="sig-name descname">_get_derivative</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">diff_axes</em>, <em class="sig-param">diff_order</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva._get_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the derivative of a signal.</p>
</dd></dl>

<dl class="function">
<dt id="hyperspy.learn.mva._normalize_components">
<code class="sig-prename descclassname">hyperspy.learn.mva.</code><code class="sig-name descname">_normalize_components</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">other</em>, <em class="sig-param">function=&lt;function sum&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.learn.mva._normalize_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize components according to a function.</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="hyperspy.learn.ornmf.html" class="btn btn-neutral float-right" title="hyperspy.learn.ornmf module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="hyperspy.learn.mlpca.html" class="btn btn-neutral float-left" title="hyperspy.learn.mlpca module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2011-2021, The HyperSpy development team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>