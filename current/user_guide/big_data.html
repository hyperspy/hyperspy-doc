<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Working with big data &mdash; HyperSpy 1.7.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hyperspy.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/toggleprompt.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Metadata structure" href="metadata_structure.html" />
    <link rel="prev" title="Events" href="events.html" />
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25260850-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> HyperSpy
            <img src="../_static/hyperspy_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.7.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing HyperSpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="signal.html">The Signal class</a></li>
<li class="toctree-l1"><a class="reference internal" href="axes.html">Axes handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactive_operations_ROIs.html">Interactive Operations and Region of Interest (ROI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="signal1d.html">Signal1D Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="signal2d.html">Signal2D Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualisation.html">Data visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="mva.html">Machine learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="model.html">Model fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="eels.html">Electron Energy Loss Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="eds.html">Energy-Dispersive X-ray Spectrometry (EDS)</a></li>
<li class="toctree-l1"><a class="reference internal" href="dielectric_function.html">Dielectric function tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="electron_holography.html">Electron Holography</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Loading and saving data</a></li>
<li class="toctree-l1"><a class="reference internal" href="events.html">Events</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Working with big data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-lazy-signals">Creating Lazy Signals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lazy-signals-from-external-data">Lazy Signals from external data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-lazily">Loading lazily</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lazy-stacking">Lazy stacking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casting-signals-as-lazy">Casting signals as lazy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#machine-learning">Machine learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#navigator-plot">Navigator plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpu-support">GPU support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#model-fitting">Model fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#practical-tips">Practical tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chunking">Chunking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computing-lazy-signals">Computing lazy signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lazy-operations-that-affect-the-axes">Lazy operations that affect the axes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">Limitations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#immutable-signals">Immutable signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-minor-differences">Other minor differences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving-big-data">Saving Big Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#behind-the-scenes-technical-details">Behind the scenes –technical details</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metadata_structure.html">Metadata structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/git.html">Using Git and GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/testing.html">Running and writing tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/writing_docs.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/coding_style.html">Coding style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/lazy_computations.html">Tips for writing methods that work on lazy signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/speeding_up_code.html">Speeding up code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/writing_extensions.html">Writing packages that extend HyperSpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/useful_information.html">Useful information</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/modules.html">hyperspy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Credits and citation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing HyperSpy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HyperSpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Working with big data</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/user_guide/big_data.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="working-with-big-data">
<span id="big-data-label"></span><h1>Working with big data<a class="headerlink" href="#working-with-big-data" title="Permalink to this heading"></a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>All the features described in this chapter are in beta state.</p>
<p>Although most of them work as described, their operation may not always
be optimal, well-documented and/or consistent with their in-memory counterparts.</p>
<p>Therefore, although efforts will be taken to minimise major disruptions,
the syntax and features described here may change in patch and minor
HyperSpy releases. If you experience issues with HyperSpy’s lazy features
please report them to the developers.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.2.</span></p>
</div>
<p>HyperSpy makes it possible to analyse data larger than the available memory by
providing “lazy” versions of most of its signals and functions. In most cases
the syntax remains the same. This chapter describes how to work with data
larger than memory using the <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazySignal</span></code></a> class and
its derivatives.</p>
<section id="creating-lazy-signals">
<h2>Creating Lazy Signals<a class="headerlink" href="#creating-lazy-signals" title="Permalink to this heading"></a></h2>
<section id="lazy-signals-from-external-data">
<h3>Lazy Signals from external data<a class="headerlink" href="#lazy-signals-from-external-data" title="Permalink to this heading"></a></h3>
<p>If the data is large and not loaded by HyperSpy (for example a <code class="docutils literal notranslate"><span class="pre">hdf5.Dataset</span></code>
or similar), first wrap it in <code class="docutils literal notranslate"><span class="pre">dask.array.Array</span></code> as shown <a class="reference external" href="https://dask.readthedocs.io/en/latest/array-creation.html">here</a> and then pass it
as normal and call <code class="docutils literal notranslate"><span class="pre">as_lazy()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s2">&quot;myfile.hdf5&quot;</span><span class="p">)</span>           <span class="c1"># Load the file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;/data/path&#39;</span><span class="p">]</span>                 <span class="c1"># Get the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>                <span class="c1"># Import dask to wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>                    <span class="c1"># Chunk as appropriate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span> <span class="c1"># Wrap the data in dask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span> <span class="c1"># Create the lazy signal</span>
</pre></div>
</div>
</section>
<section id="loading-lazily">
<h3>Loading lazily<a class="headerlink" href="#loading-lazily" title="Permalink to this heading"></a></h3>
<p>To load the data lazily, pass the keyword <code class="docutils literal notranslate"><span class="pre">lazy=True</span></code>.  As an example,
loading a 34.9 GB <code class="docutils literal notranslate"><span class="pre">.blo</span></code> file on a regular laptop might look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;shish26.02-6.blo&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (400, 333|512, 512)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span>
<span class="go">dask.array&lt;array-e..., shape=(333, 400, 512, 512), dtype=uint8, chunksize=(20, 12, 512, 512)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
<span class="go">uint8 34.9175808</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">change_dtype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="c1"># To be able to perform decomposition, etc.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
<span class="go">float64 279.3406464</span>
</pre></div>
</div>
<p>Loading the dataset in the original unsigned integer format would require
around 35GB of memory. To store it in a floating-point format one would need
almost 280GB of memory. However, with the lazy processing both of these steps
are near-instantaneous and require very little computational resources.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4: </span><a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.close_file" title="hyperspy._signals.lazy.LazySignal.close_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close_file()</span></code></a></p>
</div>
<p>Currently when loading an hdf5 file lazily the file remains open at
least while the signal exists. In order to close it explicitly, use the
<a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.close_file" title="hyperspy._signals.lazy.LazySignal.close_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close_file()</span></code></a> method. Alternatively,
you could close it on calling <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.compute" title="hyperspy._signals.lazy.LazySignal.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute()</span></code></a>
by passing the keyword argument <code class="docutils literal notranslate"><span class="pre">close_file=True</span></code> e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;file.hspy&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssum</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssum</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">close_file</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># closes the file.hspy file</span>
</pre></div>
</div>
</section>
<section id="lazy-stacking">
<h3>Lazy stacking<a class="headerlink" href="#lazy-stacking" title="Permalink to this heading"></a></h3>
<p>Occasionally the full dataset consists of many smaller files. To combine them
into a one large <code class="docutils literal notranslate"><span class="pre">LazySignal</span></code>, we can <a class="reference internal" href="signal.html#signal-stack-split"><span class="std std-ref">stack</span></a> them
lazily (both when loading or afterwards):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">siglist</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;*.hdf5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">siglist</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or load lazily and stack afterwards:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siglist</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;*.hdf5&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">siglist</span><span class="p">)</span> <span class="c1"># no need to pass &#39;lazy&#39;, as signals already lazy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or do everything in one go:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;*.hdf5&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="casting-signals-as-lazy">
<h3>Casting signals as lazy<a class="headerlink" href="#casting-signals-as-lazy" title="Permalink to this heading"></a></h3>
<p>To convert a regular HyperSpy signal to a lazy one such that any future
operations are only performed lazily, use the
<a class="reference internal" href="../api/hyperspy.signal.html#hyperspy.signal.BaseSignal.as_lazy" title="hyperspy.signal.BaseSignal.as_lazy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_lazy()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">150.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Signal1D, title: , dimensions: (3|50)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span>
<span class="go">&lt;LazySignal1D, title: , dimensions: (3|50)&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="machine-learning">
<span id="big-data-decomposition"></span><h2>Machine learning<a class="headerlink" href="#machine-learning" title="Permalink to this heading"></a></h2>
<p><a class="reference internal" href="mva.html#mva-decomposition"><span class="std std-ref">Decomposition</span></a> algorithms for machine learning often perform
large matrix manipulations, requiring significantly more memory than the data size.
To perform decomposition operation lazily, HyperSpy provides access to several “online”
algorithms  as well as <a class="reference external" href="https://dask.pydata.org/">dask</a>’s lazy SVD algorithm.
Online algorithms perform the decomposition by operating serially on chunks of
data, enabling the lazy decomposition of large datasets. In line with the
standard HyperSpy signals, lazy <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.decomposition" title="hyperspy._signals.lazy.LazySignal.decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomposition()</span></code></a>
offers the following online algorithms:</p>
<span id="lazy-decomposition-table"></span><table class="docutils align-default" id="id1">
<caption><span class="caption-text">Available lazy decomposition algorithms in HyperSpy</span><a class="headerlink" href="#id1" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p>Method</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“SVD” (default)</p></td>
<td><p><a class="reference external" href="https://docs.dask.org/en/latest/generated/dask.array.linalg.svd.html#dask.array.linalg.svd" title="(in Dask)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.linalg.svd()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>“PCA”</p></td>
<td><p><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html#sklearn.decomposition.IncrementalPCA" title="(in scikit-learn v1.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.IncrementalPCA</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>“ORPCA”</p></td>
<td><p><a class="reference internal" href="../api/hyperspy.learn.rpca.html#hyperspy.learn.rpca.ORPCA" title="hyperspy.learn.rpca.ORPCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">ORPCA</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>“ORNMF”</p></td>
<td><p><a class="reference internal" href="../api/hyperspy.learn.ornmf.html#hyperspy.learn.ornmf.ORNMF" title="hyperspy.learn.ornmf.ORNMF"><code class="xref py py-class docutils literal notranslate"><span class="pre">ORNMF</span></code></a></p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../api/hyperspy.learn.mva.html#hyperspy.learn.mva.MVA.decomposition" title="hyperspy.learn.mva.MVA.decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decomposition()</span></code></a> for more details on decomposition
with non-lazy signals.</p>
</div>
</section>
<section id="navigator-plot">
<h2>Navigator plot<a class="headerlink" href="#navigator-plot" title="Permalink to this heading"></a></h2>
<p>The default signal navigator is the sum of the signal across all signal
dimensions and all but 1 or 2 navigation dimensions. If the dataset is large,
this can take a significant amount of time to perform with every plot.
By default, a navigator is computed with minimally required approach to obtain
a good signal-to-noise ratio image: the sum is taken on a single chunk of the
signal space, in order to avoid to compute the navigator for the whole dataset.
In the following example, the signal space is divided in 25 chunks (5 along on
each axis), and therefore computing the navigation will only be perfomed over
a small subset of the whole dataset by taking the sum on only 1 chunk out
of 25:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>In the example above, the calculation of the navigation is fast but the actual
visualisation of the dataset is slow, each for each navigation index change,
25 chunks of the dataset needs to be fetched from the harddrive. In the
following example, the signal space contains a single chunk (instead of 25, in
the previous example) and the calculating the navigator will then be slower (~20x)
because the whole dataset will need to processed, however in this case, the
visualisation will be faster, because only a single chunk will fetched from the
harddrive when changing navigation indices:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>This approach depends heavily on the chunking of the data and may not be
always suitable. The <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.compute_navigator" title="hyperspy._signals.lazy.LazySignal.compute_navigator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_navigator()</span></code></a>
can be used to calculate the navigator efficient and store the navigator, so
that it can be used when plotting and saved for the later loading of the dataset.
The <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.compute_navigator" title="hyperspy._signals.lazy.LazySignal.compute_navigator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_navigator()</span></code></a> has optional
argument to specify the index where the sum needs to be calculated and how to
rechunk the dataset when calculating the navigator. This allows to
efficiently calculate the navigator without changing the actual chunking of the
dataset, since the rechunking only takes during the computation of the navigator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compute_navigator</span><span class="p">(</span><span class="n">chunks_number</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">400</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (100, 100|400, 2000)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compute_navigator</span><span class="p">(</span><span class="n">chunks_number</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">navigator</span><span class="o">.</span><span class="n">original_metadata</span>
<span class="go">└── sum_from = [slice(200, 400, None), slice(1000, 1200, None)]</span>
</pre></div>
</div>
<p>The index can also be specified following the
<a class="reference internal" href="signal.html#signal-indexing"><span class="std std-ref">HyperSpy indexing signal1D</span></a> syntax for float and
interger.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">400</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (100, 100|400, 2000)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compute_navigator</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">chunks_number</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">navigator</span><span class="o">.</span><span class="n">original_metadata</span>
<span class="go">└── sum_from = [slice(0, 200, None), slice(0, 200, None)]</span>
</pre></div>
</div>
<p>An alternative is to calculate the navigator separately and store it in the
signal using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">navigator</span></code> setter.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (100, 100|1000, 1000)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># for fastest results, just pick one signal space pixel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nav</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">isig</span><span class="p">[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Alternatively, sum as per default behaviour of non-lazy signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nav</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">signal_axes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nav</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (|100, 100)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the result</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nav</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">[########################################] | 100% Completed | 13.1s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">navigator</span> <span class="o">=</span> <span class="n">nav</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, it is possible to not have a navigator, and use sliders
instead:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (200, 200|512, 512)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">navigator</span><span class="o">=</span><span class="s1">&#39;slider&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
</section>
<section id="gpu-support">
<span id="big-data-gpu"></span><h2>GPU support<a class="headerlink" href="#gpu-support" title="Permalink to this heading"></a></h2>
<p>Lazy data processing on GPUs requires explicitly transferring the data to the
GPU.</p>
<p>On linux, it is recommended to use the
<a class="reference external" href="https://docs.rapids.ai/api/dask-cuda/stable/index.html">dask_cuda</a> library
(not supported on windows) to manage the dask scheduler. As for CPU lazy
processing, if the dask scheduler is not specified, the default scheduler
will be used.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask_cuda</span> <span class="kn">import</span> <span class="n">LocalCUDACluster</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCUDACluster</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a dask array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">... </span><span class="n">dask</span><span class="o">.</span><span class="n">array</span><span class="o">&lt;</span><span class="n">random_sample</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float64</span><span class="p">,</span>
<span class="gp">... </span><span class="n">chunksize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">chunktype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="o">&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># convert the dask chunks from numpy array to cupy array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">... </span><span class="n">dask</span><span class="o">.</span><span class="n">array</span><span class="o">&lt;</span><span class="n">random_sample</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float64</span><span class="p">,</span>
<span class="gp">... </span><span class="n">chunksize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">chunktype</span><span class="o">=</span><span class="n">cupy</span><span class="o">.</span><span class="n">ndarray</span><span class="o">&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create the signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See the dask blog on <a class="reference external" href="https://blog.dask.org/2020/11/12/deconvolution">Richardson Lucy (RL) deconvolution</a>
for an example of lazy processing on GPUs using dask and cupy</p>
</div>
</section>
<section id="model-fitting">
<span id="fitbigdata-label"></span><h2>Model fitting<a class="headerlink" href="#model-fitting" title="Permalink to this heading"></a></h2>
<p>Most curve-fitting functionality will automatically work on models created from
lazily loaded signals. HyperSpy extracts the relevant chunk from the signal and fits to that.</p>
<p>The linear <code class="docutils literal notranslate"><span class="pre">'lstsq'</span></code> optimizer supports fitting the entire dataset in a vectorised manner
using <a class="reference external" href="https://docs.dask.org/en/latest/generated/dask.array.linalg.lstsq.html#dask.array.linalg.lstsq" title="(in Dask)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.linalg.lstsq()</span></code></a>. This can give potentially enormous performance benefits over fitting
with a nonlinear fitter, but comes with the restrictions explained in the <a class="reference internal" href="model.html#linear-fitting-label"><span class="std std-ref">linear fitting</span></a> section.</p>
</section>
<section id="practical-tips">
<h2>Practical tips<a class="headerlink" href="#practical-tips" title="Permalink to this heading"></a></h2>
<p>Despite the limitations detailed below, most HyperSpy operations can be
performed lazily. Important points are:</p>
<section id="chunking">
<span id="big-data-chunking"></span><h3>Chunking<a class="headerlink" href="#chunking" title="Permalink to this heading"></a></h3>
<p>Data saved in the HDF5 format is typically divided into smaller chunks which can be loaded separately into memory,
allowing lazy loading. Chunk size can dramatically affect the speed of various HyperSpy algorithms, so chunk size is
worth careful consideration when saving a signal. HyperSpy’s default chunking sizes are probably not optimal
for a given data analysis technique. For more comprehensible documentation on chunking,
see the dask <a class="reference external" href="https://docs.dask.org/en/latest/array-chunks.html">array chunks</a> and <a class="reference external" href="https://docs.dask.org/en/latest/array-best-practices.html">best practices</a> docs. The chunks saved into HDF5 will
match the dask array chunks in <code class="docutils literal notranslate"><span class="pre">s.data.chunks</span></code> when lazy loading.
Chunk shape should follow the axes order of the numpy shape (<code class="docutils literal notranslate"><span class="pre">s.data.shape</span></code>), not the hyperspy shape.
The following example shows how to chunk one of the two navigation dimensions into smaller chunks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">chunksize</span>
<span class="go">(10, 200, 300)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="c1"># Note the reversed order of navigation dimensions</span>
<span class="go">&lt;LazSignal1D, title: , dimensions: (200, 10|300)&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;chunked_signal.hspy&#39;</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span> <span class="c1"># Chunking first hyperspy dimension (second array dimension)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;chunked_signal.hspy&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chunksize</span>
<span class="go">(10, 100, 300)</span>
</pre></div>
</div>
<p>To get the chunk size of given axes, the <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.get_chunk_size" title="hyperspy._signals.lazy.LazySignal.get_chunk_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_chunk_size()</span></code></a>
method can be used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">chunksize</span>
<span class="go">(10, 200, 300)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_chunk_size</span><span class="p">()</span> <span class="c1"># All navigation axes</span>
<span class="go">((10,), (200,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_chunk_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># The first navigation axis</span>
<span class="go">((200,),)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.2.</span></p>
</div>
<p>By default, HyperSpy tries to optimize the chunking for most operations. However,
it is sometimes possible to manually set a more optimal chunking manually. Therefore,
many operations take a <code class="docutils literal notranslate"><span class="pre">rechunk</span></code> or <code class="docutils literal notranslate"><span class="pre">optimize</span></code> keyword argument to disable
automatic rechunking.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p id="lazy-repr-html">For more recent versions of dask (dask&gt;2021.11) when using hyperspy in a jupyter
notebook a helpful html representation is available.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/chunks.png" src="../_images/chunks.png" />
</figure>
<p>This helps to visualize the chunk structure and identify axes where the chunk spans the entire
axis (bolded axes).</p>
</section>
<section id="computing-lazy-signals">
<h3>Computing lazy signals<a class="headerlink" href="#computing-lazy-signals" title="Permalink to this heading"></a></h3>
<p>Upon saving lazy signals, the result of computations is stored on disk.</p>
<p>In order to store the lazy signal in memory (i.e. make it a normal HyperSpy
signal) it has a <a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal.compute" title="hyperspy._signals.lazy.LazySignal.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;LazySignal2D, title: , dimensions: (|512, 512)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">[########################################] | 100% Completed |  0.1s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Signal2D, title: , dimensions: (|512, 512)&gt;</span>
</pre></div>
</div>
</section>
<section id="lazy-operations-that-affect-the-axes">
<h3>Lazy operations that affect the axes<a class="headerlink" href="#lazy-operations-that-affect-the-axes" title="Permalink to this heading"></a></h3>
<p>When using lazy signals the computation of the data is delayed until
requested. However, the changes to the axes properties are performed
when running a given function that modfies them i.e. they are not
performed lazily. This can lead to hard to debug issues when the result
of a given function that is computed lazily depends on the value of the
axes parameters that <em>may have changed</em> before the computation is requested.
Therefore, in order to avoid such issues, it is reccomended to explicitly
compute the result of all functions that are affected by the axes
parameters. This is the reason why e.g. the result of
<a class="reference internal" href="../api/hyperspy._signals.signal1d.html#hyperspy._signals.signal1d.Signal1D.shift1D" title="hyperspy._signals.signal1d.Signal1D.shift1D"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shift1D()</span></code></a> is not lazy.</p>
</section>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h2>
<p>Most operations can be performed lazily. However, lazy operations come with
a few limitations and constraints that we detail below.</p>
<section id="immutable-signals">
<h3>Immutable signals<a class="headerlink" href="#immutable-signals" title="Permalink to this heading"></a></h3>
<p>An important limitation when using <code class="docutils literal notranslate"><span class="pre">LazySignal</span></code> is the inability to modify
existing data (immutability). This is a logical consequence of the DAG (tree
structure, explained in <a class="reference internal" href="#lazy-details"><span class="std std-ref">Behind the scenes –technical details</span></a>), where a complete history of the
processing has to be stored to traverse later.</p>
<p>In fact, lazy evaluation removes the need for such operation, since only
additional tree branches are added, requiring very little resources. In
practical terms the following fails with lazy signals:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;ipython-input-6-1bd1db4187be&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
  File <span class="nb">&quot;&lt;string&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">__iadd__</span>
  File <span class="nb">&quot;/home/fjd29/Python/hyperspy3/hyperspy/signal.py&quot;</span>, line <span class="m">1591</span>, in <span class="n">_binary_operator_ruler</span>
    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;Array&#39; object has no attribute &#39;__iadd__&#39;</span>
</pre></div>
</div>
<p>However, when operating lazily there is no clear benefit to using in-place
operations. So, the operation above could be rewritten as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Or even better:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_lazy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="other-minor-differences">
<h3>Other minor differences<a class="headerlink" href="#other-minor-differences" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Histograms</strong> for a <code class="docutils literal notranslate"><span class="pre">LazySignal</span></code> do not support <code class="docutils literal notranslate"><span class="pre">knuth</span></code> and <code class="docutils literal notranslate"><span class="pre">blocks</span></code>
binning algorithms.</p></li>
<li><p><strong>CircleROI</strong> sets the elements outside the ROI to <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> instead of
using a masked array, because <code class="docutils literal notranslate"><span class="pre">dask</span></code> does not support masking. As a
convenience, <code class="docutils literal notranslate"><span class="pre">nansum</span></code>, <code class="docutils literal notranslate"><span class="pre">nanmean</span></code> and other <code class="docutils literal notranslate"><span class="pre">nan*</span></code> signal methods were
added to mimic the workflow as closely as possible.</p></li>
</ul>
</section>
<section id="saving-big-data">
<span id="big-data-saving"></span><h3>Saving Big Data<a class="headerlink" href="#saving-big-data" title="Permalink to this heading"></a></h3>
<p>The most efficient format supported by HyperSpy to write data is the <a class="reference internal" href="io.html#zspy-format"><span class="std std-ref">zspy format</span></a>,
mainly because it supports writing currently from concurrently from multiple threads or processes.
This also allows for smooth interaction with dask-distributed for efficient scaling.</p>
</section>
</section>
<section id="behind-the-scenes-technical-details">
<span id="lazy-details"></span><h2>Behind the scenes –technical details<a class="headerlink" href="#behind-the-scenes-technical-details" title="Permalink to this heading"></a></h2>
<p>Standard HyperSpy signals load the data into memory for fast access and
processing. While this behaviour gives good performance in terms of speed, it
obviously requires at least as much computer memory as the dataset, and often
twice that to store the results of subsequent computations. This can become a
significant problem when processing very large datasets on consumer-oriented
hardware.</p>
<p>HyperSpy offers a solution for this problem by including
<a class="reference internal" href="../api/hyperspy._signals.lazy.html#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazySignal</span></code></a> and its derivatives. The main idea of
these classes is to perform any operation (as the name suggests)
<a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily</a> (delaying the
execution until the result is requested (e.g. saved, plotted)) and in a
<a class="reference external" href="https://en.wikipedia.org/wiki/Block_matrix">blocked fashion</a>. This is
achieved by building a “history tree” (formally called a Directed Acyclic Graph
(DAG)) of the computations, where the original data is at the root, and any
further operations branch from it. Only when a certain branch result is
requested, the way to the root is found and evaluated in the correct sequence
on the correct blocks.</p>
<p>The “magic” is performed by (for the sake of simplicity) storing the data not
as <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, but <code class="docutils literal notranslate"><span class="pre">dask.array.Array</span></code> (see the
<a class="reference external" href="https://dask.readthedocs.io/en/latest/">dask documentation</a>). <code class="docutils literal notranslate"><span class="pre">dask</span></code>
offers a couple of advantages:</p>
<ul class="simple">
<li><p><strong>Arbitrary-sized data processing is possible</strong>. By only loading a couple of
chunks at a time, theoretically any signal can be processed, albeit slower.
In practice, this may be limited: (i) some operations may require certain
chunking pattern, which may still saturate memory; (ii) many chunks should
fit into the computer memory comfortably at the same time.</p></li>
<li><p><strong>Loading only the required data</strong>. If a certain part (chunk) of the data is
not required for the final result, it will not be loaded at all, saving time
and resources.</p></li>
<li><p><strong>Able to extend to a distributed computing environment (clusters)</strong>.
:py:<code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> (see
<a class="reference external" href="https://distributed.readthedocs.io/en/latest/">the dask documentation</a>) offers
a straightforward way to expand the effective memory for computations to that
of a cluster, which allows performing the operations significantly faster
than on a single machine.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="events.html" class="btn btn-neutral float-left" title="Events" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="metadata_structure.html" class="btn btn-neutral float-right" title="Metadata structure" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011-2022, The HyperSpy development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>